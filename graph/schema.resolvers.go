package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.25

import (
	"context"
	"safepasswordverification/graph/model"
	"safepasswordverification/rule"
)

// Verify is the resolver for the verify field.
func (r *queryResolver) Verify(ctx context.Context, password string, rules []*model.Rule) (*model.Verify, error) {
	var response model.Verify

	for i := 0; i < len(rules); i++ {
		switch {
		case rules[i].Rule == "minSize":
			if rule.MinSize(password, rules[i].Value) == false {
				response.NoMatch = append(response.NoMatch, &rules[i].Rule)
			}

		case rules[i].Rule == "minUppercase":
			if rule.MinUppercase(password, rules[i].Value) == false {
				response.NoMatch = append(response.NoMatch, &rules[i].Rule)
			}

		case rules[i].Rule == "minLowercase":
			if rule.MinLowercase(password, rules[i].Value) == false {
				response.NoMatch = append(response.NoMatch, &rules[i].Rule)
			}

		case rules[i].Rule == "minDigit":
			if rule.MinDigit(password, rules[i].Value) == false {
				response.NoMatch = append(response.NoMatch, &rules[i].Rule)
			}

		case rules[i].Rule == "minSpecialChars":
			if rule.MinSpecialChars(password, rules[i].Value) == false {
				response.NoMatch = append(response.NoMatch, &rules[i].Rule)
			}

		case rules[i].Rule == "noRepeated":
			if rule.NoRepeated(password) == false {
				response.NoMatch = append(response.NoMatch, &rules[i].Rule)
			}
		}

		if len(response.NoMatch) != 0 {
			response.Verify = false
		} else {
			response.Verify = true
		}

	}

	return &response, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
